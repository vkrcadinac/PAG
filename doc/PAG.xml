
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<Chapter Label="The PAG Package">
<Heading>The PAG Package</Heading>
<Index>PAG</Index>
	
<E>Prescribed Automorphism Groups</E> (&PAG;) is a &GAP; package
for constructing combinatorial objects with prescribed automorphism
groups.

<P/>

<Section Label="Getting Started">
<Heading>Getting Started</Heading>

The package is loaded by

<Example><![CDATA[gap> LoadPackage("PAG"); ]]></Example>

Let us present a small example from the paper <Cite Key='VK18'/>. 
In Theorem 8.1, a simple 5-(16,7,10) design with the following
automorphism group was constructed.

<Example><![CDATA[gap> g:=Group((2,3,4)(5,6,7,8,9,10)(11,12,13,14,15,16), 
> (1,5)(2,12)(3,15)(4,8)(6,14)(7,16)(9,10)(11,13));]]></Example>

The design can be obtained by typing

<Example><![CDATA[gap> KramerMesnerSearch(5,16,7,10,g);
Computing t-subset orbit representatives...
28
Computing k-subset orbit representatives...
71
Computing the Kramer-Mesner matrix...
[ 29, 72 ]
Starting solver...
No BOUNDS 
The RHS is fixed !
No upper bounds: 0/1 variables are assumed 

Orthogonal defect: 26.953339
First reduction successful
Orthogonal defect: 20.216092
Second reduction successful
.
.
.
]]></Example>

Comments during the calculation can be supressed by setting global options.

<Example><![CDATA[gap> PAGGlobalOptions.Silent:=true;
true
gap> d:=KramerMesnerSearch(5,16,7,10,g);
[ rec( autSubgroup := Group([ (2,3,4)(5,6,7,8,9,10)(11,12,13,14,15,16), 
          (1,5)(2,12)(3,15)(4,8)(6,14)(7,16)(9,10)(11,13) ]), 
      blocks := [ [ 1, 2, 3, 4, 5, 6, 13 ], [ 1, 2, 3, 4, 5, 6, 14 ], 
          [ 1, 2, 3, 4, 5, 7, 9 ], [ 1, 2, 3, 4, 5, 7, 12 ], 
          [ 1, 2, 3, 4, 5, 9, 16 ], [ 1, 2, 3, 4, 5, 10, 12 ], 
          [ 1, 2, 3, 4, 5, 10, 13 ], [ 1, 2, 3, 4, 5, 11, 12 ], 
          [ 1, 2, 3, 4, 5, 11, 16 ], [ 1, 2, 3, 4, 5, 12, 14 ], 
          [ 1, 2, 3, 4, 6, 7, 14 ], [ 1, 2, 3, 4, 6, 7, 15 ], 
.
.
.
]]></Example>

The output is a list of non-isomorphic designs in the <Package>Design</Package> 
package format <Ref Chap="Design" BookName="DESIGN"/>. We can check that it is 
really a 5-design.

<Example><![CDATA[gap> List(d,AllTDesignLambdas);
[ [ 2080, 910, 364, 130, 40, 10 ] ]
]]></Example>

The output is large because the <Package>Design</Package> format includes 
a list of all blocks, and 5-(16,7,10) designs have 2080 blocks. Instead, we can ask
just for the base blocks.

<Example><![CDATA[gap> bb:=KramerMesnerSearch(5,16,7,10,g,rec(BaseBlocks:=true));
[ [ [ 1, 2, 3, 4, 5, 6, 13 ], [ 1, 2, 3, 4, 5, 6, 14 ], 
      [ 1, 2, 3, 5, 6, 7, 11 ], [ 1, 2, 3, 5, 6, 8, 9 ], 
      [ 1, 2, 3, 5, 6, 9, 10 ], [ 1, 2, 3, 5, 6, 9, 12 ], 
      [ 1, 2, 3, 5, 6, 10, 15 ], [ 1, 2, 3, 5, 6, 14, 16 ], 
      [ 1, 2, 3, 5, 8, 11, 12 ], [ 1, 2, 5, 6, 7, 8, 16 ], 
      [ 1, 2, 5, 6, 7, 9, 14 ], [ 1, 2, 5, 6, 7, 12, 13 ], 
      [ 1, 2, 5, 6, 7, 14, 15 ] ], 
  [ [ 1, 2, 3, 4, 5, 6, 8 ], [ 1, 2, 3, 4, 5, 6, 14 ], 
      [ 1, 2, 3, 5, 6, 7, 11 ], [ 1, 2, 3, 5, 6, 9, 12 ], 
      [ 1, 2, 3, 5, 6, 10, 12 ], [ 1, 2, 3, 5, 6, 10, 16 ], 
      [ 1, 2, 3, 5, 6, 12, 13 ], [ 1, 2, 3, 5, 6, 14, 15 ], 
      [ 1, 2, 3, 5, 8, 11, 12 ], [ 1, 2, 5, 6, 7, 8, 9 ], 
      [ 1, 2, 5, 6, 7, 9, 14 ], [ 1, 2, 5, 6, 7, 12, 13 ], 
      [ 1, 2, 5, 6, 11, 14, 16 ] ] ]
]]></Example>

In this case isomorph rejection is not performed and we get two sets of base blocks.
They can be turned into designs by calling the 
<Ref Func="BlockDesign" BookName="DESIGN"/> function: 
<C>List(bb,x->BlockDesign(16,x,g));</C>.
</Section>

<Section Label="Installation">
<Heading>Installation</Heading>

The &PAG; package requires &GAP; 4.11 and the following packages:
<List>
	<Item><Package>Images</Package> 1.3</Item>
	<Item><Package>GRAPE</Package> 4.8</Item>
	<Item><Package>Design</Package> 1.7</Item>
</List>
The following packages are also loaded, if available. They are needed for
a limited number of &PAG; functions.
<List>
	<Item><Package>AssociationSchemes</Package> 2.0</Item>
	<Item><Package>DifSets</Package> 2.3.1</Item>
	<Item><Package>GUAVA</Package> 3.15</Item>
	<Item><Package>FinInG</Package> 1.4.1</Item>
</List>
The current installation file for &PAG; is available at 
<URL>https://vkrcadinac.github.io/PAG/</URL>.
To install &PAG;, unpack it to the <F>pkg</F> directory of 
your local &GAP; installation. The package uses external binaries. To compile 
them on UNIX-like environments, change to the <F>pkg/PAG-*</F> directory and 
call
<Log>
$ ./configure.sh
</Log> 
This produces a <F>Makefile</F> in the current directory. Now call
<Log>
$ make all
</Log> 
to compile the binares. They are placed in the <F>bin</F> subdirectory.
Documentation in the <F>doc</F> subdirectory is already compiled and
can be read in PDF, html or from within &GAP;. To recompile the
documentation, call &GAP; with the <F>makedoc.g</F> file.
</Section>

<Section Label="Examples: Designs">
<Heading>Examples: Designs</Heading>

The &PAG; function <C>KramerMesnerSearch</C> performs a search for <M>t</M>-designs 
with given parameters and a given permutation group as group of automorphisms. 
See the paper by B.&nbsp;Schmalz&nbsp;<Cite Key='BS93'/> for an introduction to 
the Kramer-Mesner approach to constructing <M>t</M>-designs. Our first two 
examples are from this paper. The original paper of Earl Kramer and Dale Mesner
is&nbsp;<Cite Key='KM76'/>. 

<Subsection Label="6-(14,7,4) Designs">
<Heading>6-(14,7,4) Designs</Heading>

The summary about known 6-designs on page 130 of <Cite Key='BS93'/> mentions
that there are exactly two 6-(14,7,4) designs with cyclic derived designs.
This means that the two 6-designs have automorphisms of order 13.
They can be constructed by the following &GAP; commands. 

<Example><![CDATA[gap> g:=Group(CyclicPerm(13));
Group([ (1,2,3,4,5,6,7,8,9,10,11,12,13) ])
gap> d:=KramerMesnerSearch(6,14,7,4,g);;
gap> List(d,AllTDesignLambdas);
[ [ 1716, 858, 396, 165, 60, 18, 4 ], [ 1716, 858, 396, 165, 60, 18, 4 ] ]
]]></Example>

The solver quickly finds 24 solutions of the Kramer-Mesner system. Most of
the computation time is used to eliminate isomorphic designs. This can be 
turned off: 

<Example><![CDATA[gap> d2:=KramerMesnerSearch(6,14,7,4,g,rec(NonIsomorphic:=false));;
gap> Size(d2);
30
gap> Size(AsSet(d2));
24
]]></Example>

Now we get a list of 30 designs. By default, A.&nbsp;Wassermann's LLL solver 
<Cite Key='AW98'/> is used; it may return the same solution more than once. 
The number of distinct designs is 24. The two non-isomorphic designs have
<M>&ZZ;_{13}</M> as their full automorphism group.
<Example><![CDATA[gap> List(d,BlockDesignAut);
[ Group([ (1,2,3,4,5,6,7,8,9,10,11,12,13) ]), 
  Group([ (1,2,3,4,5,6,7,8,9,10,11,12,13) ]) ]
]]></Example>

</Subsection>

<Subsection Label="6-(28,8,lambda) Designs">
<Heading>6-(28,8,<M>\lambda</M>) Designs</Heading>

In <Cite Key='BS93'/>, the existence of 6-(28,8,<M>\lambda</M>) designs
was established for <M>\lambda=42</M>, 63, 84, and 105. The exact numbers
of these designs with automorphism group <M>P\Gamma L(2,27)</M> were
computed. While the projective general linear groups are readily available
in &GAP; through the <C>PGL</C> command, there seems to be no equivalent
command for semilinear groups. We can get <M>P\Gamma L(2,27)</M> using the 
<Package>FinInG</Package> package, as the collineation group of the projective 
line over <M>GF(27)</M>.

<Example><![CDATA[gap> LoadPackage("FinInG");
gap> g1:=CollineationGroup(ProjectiveSpace(1,27));
The FinInG collineation group PGammaL(2,27)
]]></Example>

We need a permutation representation of this group on 28 points.

<Example><![CDATA[gap> g:=Image(ActionOnAllProjPoints(g1));
Group([ (3,28,27,26,25,24,23,22,21,20,19,18,17,4,16,15,14,13,12,11,10,9,8,7,6,5), 
  (1,2,4)(5,8,24)(6,21,10)(7,16,15)(9,25,28)(11,13,14)(12,27,23)(17,26,18)
  (19,20,22), (5,7,13)(6,10,21)(8,16,14)(9,18,22)(11,24,15)(12,27,23)(17,19,25)
  (20,28,26) ])
]]></Example>

Alternatively, we can get <M>P\Gamma L(2,27)</M> from the library of small
primitive permutation groups.

<Example><![CDATA[gap> PrimitiveGroupsOfDegree(28);
[ PGL(2, 7), PSL(2, 8), PGammaL(2, 8), PSU(3, 3), PGammaU(3, 3), PSp(6, 2), A(8), 
  S(8), PSL(2, 27), PGL(2, 27), PSL(2, 27):3, PGammaL(2, 27), A(28), S(28) ]
]]></Example>

Now we can construct the designs with <M>\lambda=42</M>.

<Example><![CDATA[gap> d:=KramerMesnerSearch(6,28,8,42,g,rec(BaseBlocks:=true));;
gap> Size(AsSet(d));
3
]]></Example>

Most of the CPU time in the example above was used to compute the Kramer-Mesner
matrix. The left side of the Kramer-Mesner system is the same matrix for
all <M>\lambda</M>, so we can compute it once and reuse it to save time.

<Example><![CDATA[gap> tsub:=SubsetOrbitRep(g,28,6);;
gap> ksub:=SubsetOrbitRep(g,28,8);;
gap> m:=KramerMesnerMat(g,tsub,ksub);;
]]></Example>

Now we can quickly get the exact numbers of designs from the paper <Cite Key='BS93'/>.

<Example><![CDATA[gap> Size(AsSet(SolveKramerMesner(ExpandMatRHS(m,42))));
3
gap> Size(AsSet(SolveKramerMesner(ExpandMatRHS(m,63))));
367
gap> Size(AsSet(SolveKramerMesner(ExpandMatRHS(m,84))));
21743
gap> Size(AsSet(SolveKramerMesner(ExpandMatRHS(m,105))));
38277
]]></Example>

</Subsection>

<Subsection Label="2-(81,6,2) Designs">
<Heading>2-(81,6,2) Designs</Heading>

The first simple 2-(81,6,2) design was recently found by 
A.&nbsp;Nakic&nbsp;<Cite Key='AN21'/>. Here are the base 
blocks of this design copy-pasted from the paper.

<Example><![CDATA[gap> bb:=[[[0,0,0,0],[0,0,0,1],[0,0,0,2],[0,1,0,0],[0,1,0,1],[0,1,0,2]],
> [[0,0,0,0],[0,0,1,1],[0,0,2,2],[2,1,0,0],[2,1,1,1],[2,1,2,2]],
> [[0,0,0,0],[0,1,1,1],[0,2,2,2],[0,0,1,0],[0,1,2,1],[0,2,0,2]],
> [[0,0,0,0],[0,1,2,0],[0,2,1,0],[2,0,2,1],[2,1,1,1],[2,2,0,1]],
> [[0,0,0,0],[1,0,0,0],[2,0,0,0],[0,2,2,1],[1,2,2,1],[2,2,2,1]],
> [[0,0,0,0],[1,0,1,0],[2,0,2,0],[0,1,0,0],[1,1,1,0],[2,1,2,0]],
> [[0,0,0,0],[1,0,1,1],[2,0,2,2],[0,0,2,0],[1,0,0,1],[2,0,1,2]],
> [[0,0,0,0],[1,0,2,0],[2,0,1,0],[0,2,1,1],[1,2,0,1],[2,2,2,1]],
> [[0,0,0,0],[1,0,2,2],[2,0,1,1],[0,1,2,1],[1,1,1,0],[2,1,0,2]],
> [[0,0,0,0],[1,1,0,0],[2,2,0,0],[0,2,0,1],[1,0,0,1],[2,1,0,1]],
> [[0,0,0,0],[1,1,0,1],[2,2,0,2],[0,2,2,0],[1,0,2,1],[2,1,2,2]],
> [[0,0,0,0],[1,1,2,0],[2,2,1,0],[0,0,2,1],[1,1,1,1],[2,2,0,1]],
> [[0,0,0,0],[1,1,2,1],[2,2,1,2],[0,2,1,1],[1,0,0,2],[2,1,2,0]],
> [[0,0,0,0],[1,1,2,2],[2,2,1,1],[0,2,2,0],[1,0,1,2],[2,1,0,1]],
> [[0,0,0,0],[1,2,1,2],[2,1,2,1],[0,0,2,1],[1,2,0,0],[2,1,1,2]],
> [[0,0,0,0],[1,2,2,0],[2,1,1,0],[0,2,2,1],[1,1,1,1],[2,0,0,1]]]*Z(3)^0;;
]]></Example>

The points of this design are elements of the 4-dimensional vector
space <M>V</M> over <M>GF(3)</M>. Here is how to get the desing in 
the <Package>Design</Package> package format.

<Example><![CDATA[gap> V:=Tuples([0,1,2],4)*Z(3)^0;;
gap> d1:=Union(List(bb,y->List(V,x->AsSet(x+y))));;
gap> d:=BlockDesign(81,List(d1,y->List(y,x->Position(V,x))));;
gap> AllTDesignLambdas(d);
[ 432, 32, 2 ]
]]></Example>

The full automorphism group of the design is of order 2592. It is a semidirect 
product of the additive group of <M>V</M> and a group of order 32.

<Example><![CDATA[gap> aut:=BlockDesignAut(d);
<permutation group with 5 generators>
gap> Size(aut);
2592
gap> StructureDescription(aut);
"(C3 x C3 x C3 x C3) : (C16 : C2)"
]]></Example>

This group has three subgroups of order 648 up to conjugation. We can use
the second subgroup to construct four more simple 2-(81,6,2) designs.

<Example><![CDATA[gap> g:=Filtered(AllSubgroupsConjugation(aut),x->Size(x)=648);
[ <permutation group of size 648 with 7 generators>, 
  <permutation group of size 648 with 7 generators>, 
  <permutation group of size 648 with 7 generators> ]
gap> dd:=KramerMesnerSearch(2,81,6,2,g[2]);;
gap> List(dd,x->Size(AutomorphismGroup(x)));
[ 1296, 2592, 3888, 1944, 15552 ]
]]></Example>

Two of the new designs have larger full automorphism groups than
the design from&nbsp;<Cite Key='AN21'/>. Using their subgroups, 
more simple 2-(81,6,2) designs can be constructed.

</Subsection>

<Subsection Label="Quasi-symmetric 2-(56,16,18) Designs">
<Heading>Quasi-symmetric 2-(56,16,18) Designs</Heading>

Here is how the quasi-symmetric 2-(56,16,18) designs with intersection 
numbers <M>x=4</M>, <M>y=8</M> from the paper&nbsp;<Cite Key='KV16'/> 
can be constructed. 

<Example><![CDATA[gap> g:=Group((1,2,3,4,5)(6,7,8,9,10)(11,12,13,14,15)(16,17,18,19,20)
>   (21,22,23,24,25)(26,27,28,29,30)(31,32,33,34,35)(36,37,38,39,40)
>   (41,42,43,44,45)(46,47,48,49,50)(51,52,53,54,55),
> (1,6,8)(2,21,26)(3,32,34)(4,11,5)(7,15,22)(9,16,13)(10,29,17)
>   (12,33,30)(14,19,31)(18,23,35)(24,28,36)(25,37,39)(27,38,40)
>   (42,51,49)(43,52,45)(44,46,47)(48,54,53)(50,56,55));
<permutation group with 2 generators>
gap> d:=KramerMesnerSearch(2,56,16,18,g,rec(IntersectionNumbers:=[4,8]));;
gap> Size(d);
3
]]></Example>

We check that they have all required properties and compute their full automorphism
groups:

<Example><![CDATA[gap> List(d,AllTDesignLambdas);
[ [ 231, 66, 18 ], [ 231, 66, 18 ], [ 231, 66, 18 ] ]
gap> List(d,IntersectionNumbers);
[ [ 4, 8 ], [ 4, 8 ], [ 4, 8 ] ]
gap> aut:=List(d,BlockDesignAut);;
gap> List(aut,StructureDescription);
[ "(C2 x C2 x C2 x C2) : S5", "(C2 x C2 x C2 x C2) : A5", "PSL(3,4) : C2" ]
]]></Example>

</Subsection>

</Section>

<Section Label="Examples: Latin Squares">
<Heading>Examples: Latin Squares</Heading>

See&nbsp;<Cite Key='KD15'/> for an introduction to Latin squares and definitions 
of isotopy, paratopy, etc. Multiplication tables of groups are examples of Latin 
squares.

<Example><![CDATA[gap> CayleyTableOfGroup(CyclicGroup(7));
[ [ 1, 2, 3, 4, 5, 6, 7 ], 
  [ 2, 3, 4, 5, 6, 7, 1 ], 
  [ 3, 4, 5, 6, 7, 1, 2 ], 
  [ 4, 5, 6, 7, 1, 2, 3 ], 
  [ 5, 6, 7, 1, 2, 3, 4 ], 
  [ 6, 7, 1, 2, 3, 4, 5 ], 
  [ 7, 1, 2, 3, 4, 5, 6 ] ]
]]></Example>

We can construct more examples by prescribing symmetry groups.
The &PAG; function <C>KramerMesnerMOLS</C> performs a search 
for sets of <M>s</M> mutually orthogonal Latin squares (MOLS) 
of order <M>n</M> and a given permutation group as autotopy or 
autoparatopy group. The group must act on the <M>s+2</M> point
classes of the corresponding transversal design.
By&nbsp;<Cite Key='RF12'/> and&nbsp;<Cite Key='SVW12'/>, an autotopism
of order 5 of a Latin square of order 7 must have the following cycle
structure. 

<Example><![CDATA[gap> a:=MultiPerm(CyclicPerm(5),[1..7],3);
(1,2,3,4,5)(8,9,10,11,12)(15,16,17,18,19)
]]></Example>

There are two main classes of such Latin squares. They are multiplication 
tables of non-associative quasigroups.

<Example><![CDATA[gap> KramerMesnerMOLS(7,1,Group(a));
[ [ [ [ 1, 3, 2, 6, 7, 4, 5 ], 
          [ 7, 2, 4, 3, 6, 5, 1 ], 
          [ 6, 7, 3, 5, 4, 1, 2 ], 
          [ 5, 6, 7, 4, 1, 2, 3 ], 
          [ 2, 1, 6, 7, 5, 3, 4 ], 
          [ 3, 4, 5, 1, 2, 6, 7 ], 
          [ 4, 5, 1, 2, 3, 7, 6 ] ] ], 
  [ [ [ 1, 3, 5, 6, 7, 2, 4 ], 
          [ 7, 2, 4, 1, 6, 3, 5 ], 
          [ 6, 7, 3, 5, 2, 4, 1 ], 
          [ 3, 6, 7, 4, 1, 5, 2 ], 
          [ 2, 4, 6, 7, 5, 1, 3 ], 
          [ 4, 5, 1, 2, 3, 6, 7 ], 
          [ 5, 1, 2, 3, 4, 7, 6 ] ] ] ]
]]></Example>

Single Latin squares are treated as MOLS sets of size <M>s=1</M>, hence the excess brackets.
When the order <M>n</M> is a prime power, complete sets of <M>s=n-1</M> MOLS are
easily constructed from finite fields.

<Example><![CDATA[gap> ls4:=FieldToMOLS(GF(4));
[ [ [ 1, 2, 3, 4 ], 
      [ 2, 1, 4, 3 ], 
      [ 3, 4, 1, 2 ], 
      [ 4, 3, 2, 1 ] ], 
  [ [ 1, 2, 3, 4 ], 
      [ 3, 4, 1, 2 ], 
      [ 4, 3, 2, 1 ], 
      [ 2, 1, 4, 3 ] ], 
  [ [ 1, 2, 3, 4 ], 
      [ 4, 3, 2, 1 ], 
      [ 2, 1, 4, 3 ], 
      [ 3, 4, 1, 2 ] ] ]
gap> AreMOLS(ls4);
true
]]></Example>

The package <Package>Guava</Package> contains a function 
<Ref Func="AreMOLS" BookName="Guava"/> to test sets of MOLS. 
A famous problem is to find MOLS of order 10. The Handbook of
Combinatorial Designs&nbsp;<Cite Key='CD07'/>, III.5.6 contains
an example of a 1-diagonally cyclic self-orthogonal Latin square 
<M>L</M> of order 10. Self-orthogonal means that <M>L</M>
is orthogonal to its transpose. In other words, the MOLS set <M>\{L,L^t\}</M>
is invariant under the following conjugation, simultaneously exchanging rows&ndash;columns
and the two Latin squares.

<Example><![CDATA[gap> c:=Sortex(Concatenation([11..20],[1..10],[31..40],[21..30]));
(1,11)(2,12)(3,13)(4,14)(5,15)(6,16)(7,17)(8,18)(9,19)(10,20)(21,
31)(22,32)(23,33)(24,34)(25,35)(26,36)(27,37)(28,38)(29,39)(30,40)
]]></Example>

Furthermore, the example from&nbsp;<Cite Key='CD07'/> has an autotopism of order 9.

<Example><![CDATA[gap> a:=MultiPerm(CyclicPerm(9),[1..10],4);
(1,2,3,4,5,6,7,8,9)(11,12,13,14,15,16,17,18,19)(21,22,23,24,25,26,
27,28,29)(31,32,33,34,35,36,37,38,39)
]]></Example>

The permutations <M>a</M> and <M>c</M> generate an autoparatopy group of 
order 18 we can use to construct the example.

<Example><![CDATA[gap> g:=Group(a,c);;
gap> Size(g);
18
gap> ls10:=KramerMesnerMOLS(10,2,g);;
gap> List(ls10,AreMOLS);
[ true, true, true, true, true ]
]]></Example>

We see that there are 5 inequivalent pairs of MOLS with <M>g</M> as autoparatopy group. 
Here is one pair.

<Example><![CDATA[gap> ls10[1];
[ [ [ 1, 3, 6, 9, 2, 10, 5, 7, 4, 8 ], 
      [ 5, 2, 4, 7, 1, 3, 10, 6, 8, 9 ], 
      [ 9, 6, 3, 5, 8, 2, 4, 10, 7, 1 ], 
      [ 8, 1, 7, 4, 6, 9, 3, 5, 10, 2 ], 
      [ 10, 9, 2, 8, 5, 7, 1, 4, 6, 3 ], 
      [ 7, 10, 1, 3, 9, 6, 8, 2, 5, 4 ], 
      [ 6, 8, 10, 2, 4, 1, 7, 9, 3, 5 ], 
      [ 4, 7, 9, 10, 3, 5, 2, 8, 1, 6 ], 
      [ 2, 5, 8, 1, 10, 4, 6, 3, 9, 7 ], 
      [ 3, 4, 5, 6, 7, 8, 9, 1, 2, 10 ] ], 
  [ [ 1, 5, 9, 8, 10, 7, 6, 4, 2, 3 ], 
      [ 3, 2, 6, 1, 9, 10, 8, 7, 5, 4 ], 
      [ 6, 4, 3, 7, 2, 1, 10, 9, 8, 5 ], 
      [ 9, 7, 5, 4, 8, 3, 2, 10, 1, 6 ], 
      [ 2, 1, 8, 6, 5, 9, 4, 3, 10, 7 ], 
      [ 10, 3, 2, 9, 7, 6, 1, 5, 4, 8 ], 
      [ 5, 10, 4, 3, 1, 8, 7, 2, 6, 9 ], 
      [ 7, 6, 10, 5, 4, 2, 9, 8, 3, 1 ], 
      [ 4, 8, 7, 10, 6, 5, 3, 1, 9, 2 ], 
      [ 8, 9, 1, 2, 3, 4, 5, 6, 7, 10 ] ] ]
]]></Example>

</Section>

<Section Label="Examples: Cubes of Symmetric Designs">
<Heading>Examples: Cubes of Symmetric Designs</Heading>

Cubes of symmetric designs are studied in the paper <Cite Key='KPT23'/>.
Here is an example.

<Example><![CDATA[gap> c:=DifferenceCube(Group((1,2,3,4,5,6,7)),[1,2,4],3);
[ [ [ 1, 1, 0, 1, 0, 0, 0 ], 
     [ 1, 0, 1, 0, 0, 0, 1 ], 
     [ 0, 1, 0, 0, 0, 1, 1 ], 
     [ 1, 0, 0, 0, 1, 1, 0 ], 
     [ 0, 0, 0, 1, 1, 0, 1 ], 
     [ 0, 0, 1, 1, 0, 1, 0 ], 
     [ 0, 1, 1, 0, 1, 0, 0 ] ], 
  [ [ 1, 0, 1, 0, 0, 0, 1 ], 
     [ 0, 1, 0, 0, 0, 1, 1 ], 
     [ 1, 0, 0, 0, 1, 1, 0 ], 
     [ 0, 0, 0, 1, 1, 0, 1 ], 
     [ 0, 0, 1, 1, 0, 1, 0 ], 
     [ 0, 1, 1, 0, 1, 0, 0 ], 
     [ 1, 1, 0, 1, 0, 0, 0 ] ], 
  [ [ 0, 1, 0, 0, 0, 1, 1 ], 
      [ 1, 0, 0, 0, 1, 1, 0 ], 
      [ 0, 0, 0, 1, 1, 0, 1 ], 
      [ 0, 0, 1, 1, 0, 1, 0 ], 
      [ 0, 1, 1, 0, 1, 0, 0 ], 
      [ 1, 1, 0, 1, 0, 0, 0 ], 
      [ 1, 0, 1, 0, 0, 0, 1 ] ], 
  [ [ 1, 0, 0, 0, 1, 1, 0 ], 
      [ 0, 0, 0, 1, 1, 0, 1 ], 
      [ 0, 0, 1, 1, 0, 1, 0 ], 
      [ 0, 1, 1, 0, 1, 0, 0 ], 
      [ 1, 1, 0, 1, 0, 0, 0 ], 
      [ 1, 0, 1, 0, 0, 0, 1 ], 
      [ 0, 1, 0, 0, 0, 1, 1 ] ], 
  [ [ 0, 0, 0, 1, 1, 0, 1 ], 
      [ 0, 0, 1, 1, 0, 1, 0 ], 
      [ 0, 1, 1, 0, 1, 0, 0 ], 
      [ 1, 1, 0, 1, 0, 0, 0 ], 
      [ 1, 0, 1, 0, 0, 0, 1 ], 
      [ 0, 1, 0, 0, 0, 1, 1 ], 
      [ 1, 0, 0, 0, 1, 1, 0 ] ], 
  [ [ 0, 0, 1, 1, 0, 1, 0 ], 
      [ 0, 1, 1, 0, 1, 0, 0 ], 
      [ 1, 1, 0, 1, 0, 0, 0 ], 
      [ 1, 0, 1, 0, 0, 0, 1 ], 
      [ 0, 1, 0, 0, 0, 1, 1 ], 
      [ 1, 0, 0, 0, 1, 1, 0 ], 
      [ 0, 0, 0, 1, 1, 0, 1 ] ], 
  [ [ 0, 1, 1, 0, 1, 0, 0 ], 
      [ 1, 1, 0, 1, 0, 0, 0 ], 
      [ 1, 0, 1, 0, 0, 0, 1 ], 
      [ 0, 1, 0, 0, 0, 1, 1 ], 
      [ 1, 0, 0, 0, 1, 1, 0 ], 
      [ 0, 0, 0, 1, 1, 0, 1 ], 
      [ 0, 0, 1, 1, 0, 1, 0 ] ] ]
]]></Example>

This is a <M>3</M>-dimensional array of zeros and ones such that all
<M>2</M>-dimensional slices are incidence matrices of <M>(7,3,1)</M> 
designs. For example, here is a slice obtained by varying coordinates
<M>1,3</M> and setting coordinate <M>2</M> to <M>7</M>.

<Example><![CDATA[gap> m:=CubeSlice(c,1,3,[7]);
[ [ 0, 1, 1, 0, 1, 0, 0 ], 
  [ 1, 1, 0, 1, 0, 0, 0 ], 
  [ 1, 0, 1, 0, 0, 0, 1 ], 
  [ 0, 1, 0, 0, 0, 1, 1 ], 
  [ 1, 0, 0, 0, 1, 1, 0 ], 
  [ 0, 0, 0, 1, 1, 0, 1 ], 
  [ 0, 0, 1, 1, 0, 1, 0 ] ]
gap> m*TransposedMat(m);
[ [ 3, 1, 1, 1, 1, 1, 1 ], 
  [ 1, 3, 1, 1, 1, 1, 1 ], 
  [ 1, 1, 3, 1, 1, 1, 1 ], 
  [ 1, 1, 1, 3, 1, 1, 1 ], 
  [ 1, 1, 1, 1, 3, 1, 1 ], 
  [ 1, 1, 1, 1, 1, 3, 1 ], 
  [ 1, 1, 1, 1, 1, 1, 3 ] ]
]]></Example>

A cube of arbitrary dimension <M>n\ge 2</M> can be constructed from a 
difference set in a group by calling <Ref Func="DifferenceCube"/>. 
The function uses the representation of difference sets from the 
<Package>DifSets</Package> package <Ref Sect="Difference Sets" BookName="DifSets"/>. 
For <M>n=2</M>, the difference cube is simply an incidence matrix of the associated 
symmetric design, i.e. the development of the difference set. 

<Example><![CDATA[gap> g:=SmallGroup(15,1);
<pc group of size 15 with 2 generators>
gap> StructureDescription(g);
"C15"
gap> ds:=DifferenceSets(g);
[ [ 1, 2, 3, 4, 8, 11, 12 ] ]
gap> m:=DifferenceCube(g,ds[1],2);
[ [ 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0 ], 
  [ 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1 ], 
  [ 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1 ], 
  [ 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0 ], 
  [ 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1 ], 
  [ 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0 ], 
  [ 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1 ], 
  [ 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1 ], 
  [ 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0 ], 
  [ 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0 ], 
  [ 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0 ], 
  [ 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0 ], 
  [ 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1 ], 
  [ 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0 ], 
  [ 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1 ] ]
gap> d:=BlockDesign(15,List(m,x->Positions(x,1)));;
gap> AllTDesignLambdas(d);
[ 15, 7, 3 ]
]]></Example>

The function <Ref Func="DifferenceSets" BookName="DifSets"/> returns 
a list of all difference sets up to equivalence in a given group.
Here is a small <M>4</M>-dimensional <M>(3,2,1)</M> cube.

<Example><![CDATA[gap> c:=DifferenceCube(Group((1,2,3)),[1,2],4);
[ [ [ [ 1, 1, 0 ], [ 1, 0, 1 ], [ 0, 1, 1 ] ], 
      [ [ 1, 0, 1 ], [ 0, 1, 1 ], [ 1, 1, 0 ] ], 
      [ [ 0, 1, 1 ], [ 1, 1, 0 ], [ 1, 0, 1 ] ] ], 
  [ [ [ 1, 0, 1 ], [ 0, 1, 1 ], [ 1, 1, 0 ] ], 
      [ [ 0, 1, 1 ], [ 1, 1, 0 ], [ 1, 0, 1 ] ], 
      [ [ 1, 1, 0 ], [ 1, 0, 1 ], [ 0, 1, 1 ] ] ], 
  [ [ [ 0, 1, 1 ], [ 1, 1, 0 ], [ 1, 0, 1 ] ], 
      [ [ 1, 1, 0 ], [ 1, 0, 1 ], [ 0, 1, 1 ] ], 
      [ [ 1, 0, 1 ], [ 0, 1, 1 ], [ 1, 1, 0 ] ] ] ]
gap> CubeTest(c);
[ [ 3, 2, 1 ] ]
]]></Example>

The function <Ref Func="CubeTest"/> looks at all possible slices and checks if
they are incidence matrices of <M>(v,k,\lambda)</M> designs. In the next example
we construct all <M>3</M>-dimensional difference cubes of order <M>21</M>.

<Example><![CDATA[gap> g:=AllSmallGroups(21);;
gap> List(g,StructureDescription);
[ "C7 : C3", "C21" ]
gap> ds:=List(g,DifferenceSets);
[ [ [ 1, 2, 3, 9, 10 ] ], [ [ 1, 2, 7, 10, 16 ] ] ]
gap> c1:=DifferenceCube(g[1],ds[1][1],3);;
gap> c2:=DifferenceCube(g[2],ds[2][1],3);;
gap> List([c1,c2],CubeTest);
[ [ [ 21, 5, 1 ] ], [ [ 21, 5, 1 ] ] ]
gap> Size(CubeAut(c1));
1323
gap> Size(CubeAut(c2));
2646
]]></Example>

The function <Ref Func="CubeAut"/> computes the full autotopy group of a cube.
By setting options, full autoparatopy groups can also be obtained.
We can make a non-difference cube by the "group cube" construction of Theorem 4.1 
from <Cite Key='KPT23'/>. First we search for all <M>(21,5,1)</M> designs
with blocks being difference sets in the Frobenius group of order <M>21</M>.

<Example><![CDATA[gap> allds:=Filtered(Combinations([1..21],5),x->IsDifferenceSet(g[1],x));;
gap> Size(allds);
294
gap> A:=KramerMesnerMat(Group(()),Combinations([1..21],2),allds,1,21);;
gap> PAGGlobalOptions.Silent:=true;;
gap> sol:=AsSet(SolveKramerMesner(A));;
gap> des:=List(sol,x->BaseBlocks(allds,x));;
gap> Size(des);
70
]]></Example>

Among these <M>70</M> designs, <M>14</M> are left developments, and <M>14</M> are right
developments. The remaining <M>42</M> designs are not developments, but all of their 
blocks are difference sets.

<Example><![CDATA[gap> dev1:=AsSet(List(allds,x->LeftDevelopment(g[1],x).blocks));;
gap> Size(dev1);
14
gap> dev2:=AsSet(List(allds,x->RightDevelopment(g[1],x).blocks));;
gap> Size(dev2);
14
gap> nondev:=Difference(des,Union(dev1,dev2));;
gap> Size(nondev);
42
]]></Example>

Now we apply the group cube construction to these <M>42</M> designs.
The obtained cubes are equivalent.

<Example><![CDATA[gap> cc:=List(nondev,x->GroupCube(g[1],x,3));;
gap> Size(CubeFilter(cc));
1
]]></Example>

The function <Ref Func="CubeFilter"/> eliminates equivalent copies from a list of  
cubes. Our new cube is not equivalent with the two <M>(21,5,1)</M> difference cubes.

<Example><![CDATA[gap> c3:=cc[1];;
gap> CubeTest(c3);
[ [ 21, 5, 1 ] ]
gap> Size(CubeFilter([c1,c2,c3]));
3
gap> Size(CubeAut(c3));
441
]]></Example>

However, the three cubes have the same slice invariant; 
see&nbsp;<Cite Key='KPT23'/> for the definition.

<Example><![CDATA[gap> List([c1,c2,c3],SliceInvariant);
[ [ [ [ [ 120960, 21 ] ], 3 ] ], [ [ [ [ 120960, 21 ] ], 3 ] ], 
  [ [ [ [ 120960, 21 ] ], 3 ] ] ]
]]></Example>

Cubes with slice invariants different from any difference cube
can be constructed for parameters of the form 
<M>(4^m,2^{m-1}(2^m-1),2^{m-1}(2^{m-1}-1))</M>, <M>m\ge 2</M>.

<Example><![CDATA[gap> m:=2;; n:=3;;
gap> cl:=List([1,2,3],i->GroupCube(SDPSeriesGroup(m),SDPSeriesDesign(m,i),n));;
gap> List(cl,CubeTest);
[ [ [ 16, 6, 2 ] ], [ [ 16, 6, 2 ] ], [ [ 16, 6, 2 ] ] ]
gap> List(cl,SliceInvariant);
[ [ [ [ [ 11520, 16 ] ], 3 ] ], 
  [ [ [ [ 768, 16 ] ], 2 ], [ [ [ 11520, 16 ] ], 1 ] ], 
  [ [ [ [ 384, 16 ] ], 2 ], [ [ [ 11520, 16 ] ], 1 ] ] ]
]]></Example>

The first cube in the list <C>cl</C> is a difference cube. The other two cubes
are not, because they have non-isomorphic slices in different directions. This 
construction works for all <M>m\ge 2</M> and dimensions <M>n\ge 3</M>,
but it takes a lot of time and memory for bigger values of <M>m</M> 
and&nbsp;<M>n</M>. We classified all 3-dimensional group cubes of <M>(16,6,2)</M> 
designs; they are available at 
<URL>https://web.math.pmf.unizg.hr/~krcko/results/cubes.html</URL>. A list of
1423 non-group cubes of <M>(16,6,2)</M> designs is also provided.

<P/>

The package <Package>DifSets</Package> contains precomputed lists of difference
sets up to equivalence. They are loaded by the function <Ref Func="LoadDifferenceSets" 
BookName="DifSets"/>. We can use them to compute all difference cubes up to equivalence.

<Example><![CDATA[gap> v:=27;
27
gap> l1:=Concatenation(List([1..NrSmallGroups(v)],
> i->List(LoadDifferenceSets(v,i),x->[i,x])));
[ [ 4, [ 1, 2, 3, 4, 5, 6, 9, 12, 16, 19, 20, 23, 26 ] ], 
  [ 4, [ 1, 2, 3, 4, 5, 7, 8, 9, 13, 15, 18, 19, 23 ] ], 
  [ 5, [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 15, 23, 25, 27 ] ] ]
]]></Example>

The list <C>l1</C> now contains all inequivalent difference sets in groups
of order 27. The first entry is the group ID from the &GAP; library of small
groups, followed by the difference set.

<Example><![CDATA[gap> StructureDescription(SmallGroup(27,4));
"C9 : C3"
gap> StructureDescription(SmallGroup(27,5));
"C3 x C3 x C3"
gap> l2:=List(l1,x->DifferenceCube(SmallGroup(v,x[1]),x[2],3));;
gap> l3:=l1{CubeFilter(l2,rec(Positions:=true))};
[ [ 4, [ 1, 2, 3, 4, 5, 6, 9, 12, 16, 19, 20, 23, 26 ] ], 
  [ 5, [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 15, 23, 25, 27 ] ] ]
]]></Example>

The list <C>l3</C> contains difference sets giving 3-cubes that are
inequivalent (not paratopic). Notice that the two cubes arising from difference 
sets in <M>&ZZ;_9\rtimes &ZZ;_3</M> (group ID 4) are paratopic, but not isotopic:

<Example><![CDATA[gap> l4:=l1{CubeFilter(l2,rec(Positions:=true,Isotopy:=true))};
[ [ 4, [ 1, 2, 3, 4, 5, 6, 9, 12, 16, 19, 20, 23, 26 ] ], 
  [ 4, [ 1, 2, 3, 4, 5, 7, 8, 9, 13, 15, 18, 19, 23 ] ], 
  [ 5, [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 15, 23, 25, 27 ] ] ]
]]></Example>

<P/>

We will now construct some non-difference group cubes in <M>&ZZ;_9\rtimes &ZZ;_3</M>.
Here is an efficient way to get all difference sets, including equivalent ones.

<Example><![CDATA[gap> g:=SmallGroup(v,4);
<pc group of size 27 with 3 generators>
gap> ge:=ExtendedPermRepresentation(g);
<permutation group with 7 generators>
gap> ds:=LoadDifferenceSets(v,4);
[ [ 1, 2, 3, 4, 5, 6, 9, 12, 16, 19, 20, 23, 26 ], 
  [ 1, 2, 3, 4, 5, 7, 8, 9, 13, 15, 18, 19, 23 ] ]
gap> allds:=Union(List(ds,x->Orbit(ge,x,OnSets)));;
gap> Size(allds);
972
]]></Example>

For parameters <M>(21,5,1)</M> we could search for all designs with difference sets as blocks.
This would take too much time for <M>(27,13,6)</M>, so we prescribe an automorphism group of
order&nbsp;3.  
		
<Example><![CDATA[gap> sub:=AllSubgroupsConjugation(ge);;
gap> h:=sub[4];
Group([ (1,10,4)(2,15,7)(3,17,9)(5,20,12)(6,22,14)(8,23,16)
  (11,25,19)(13,26,21)(18,27,24) ])
gap> alldsorb:=List(Orbits(h,allds,OnSets),Representative);;
gap> Size(alldsorb);
324
gap> pairsorb:=List(Orbits(h,Combinations([1..27],2),OnSets),Representative);;
gap> Size(pairsorb);
117
gap> A:=KramerMesnerMat(h,pairsorb,alldsorb,6,27);;
gap> sol:=AsSet(SolveKramerMesner(A));;
gap> des:=List(sol,x->BlockDesign(27,BaseBlocks(alldsorb,x),h).blocks);;
gap> Size(des);
288
]]></Example>

We get 288 designs with difference sets as blocks. Let us remove the ones which
are developments of their blocks.

<Example><![CDATA[gap> dev1:=AsSet(List(allds,x->LeftDevelopment(g,x).blocks));;
gap> dev2:=AsSet(List(allds,x->RightDevelopment(g,x).blocks));;
gap> nondev:=List(Difference(des,Union(dev1,dev2)),x->[4,x]);;
gap> Size(nondev);
216
]]></Example>

Next, we remove the ones leading to equivalent 3-cubes.

<Example><![CDATA[gap> cc:=List(nondev,x->GroupCube(SmallGroup(v,x[1]),x[2],3));;
gap> l5:=nondev{CubeFilter(cc,rec(Positions:=true))};
[ [ 4, 
      [ [ 1, 2, 3, 4, 5, 6, 9, 12, 16, 19, 20, 23, 26 ], 
          [ 1, 2, 3, 4, 5, 7, 10, 13, 14, 19, 21, 22, 24 ], 
          [ 1, 2, 3, 7, 11, 12, 13, 15, 20, 23, 24, 25, 27 ], 
          [ 1, 2, 4, 6, 10, 11, 13, 14, 15, 17, 18, 20, 26 ], 
          [ 1, 2, 4, 8, 9, 12, 13, 16, 17, 18, 22, 24, 27 ], 
          [ 1, 2, 9, 10, 11, 14, 16, 17, 19, 21, 23, 25, 27 ], 
          [ 1, 3, 4, 7, 8, 11, 17, 18, 19, 22, 23, 25, 26 ], 
          [ 1, 3, 5, 8, 9, 10, 14, 15, 18, 23, 24, 26, 27 ], 
          [ 1, 3, 5, 8, 10, 11, 12, 15, 16, 17, 20, 21, 22 ], 
          [ 1, 4, 6, 7, 9, 10, 12, 15, 21, 22, 25, 26, 27 ], 
          [ 1, 5, 6, 7, 9, 11, 14, 16, 18, 20, 22, 24, 25 ], 
          [ 1, 5, 6, 8, 13, 17, 19, 20, 21, 24, 25, 26, 27 ], 
          [ 1, 6, 7, 8, 12, 13, 14, 15, 16, 18, 19, 21, 23 ], 
          [ 2, 3, 5, 6, 9, 13, 15, 17, 18, 21, 22, 23, 25 ], 
          [ 2, 3, 6, 7, 8, 9, 11, 12, 14, 17, 21, 24, 26 ], 
          [ 2, 3, 6, 8, 10, 12, 14, 18, 19, 20, 22, 25, 27 ], 
          [ 2, 4, 5, 7, 8, 9, 11, 15, 18, 19, 20, 21, 27 ], 
          [ 2, 4, 8, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26 ], 
          [ 2, 5, 6, 7, 8, 10, 11, 13, 16, 22, 23, 26, 27 ], 
          [ 2, 5, 7, 10, 12, 15, 16, 17, 18, 19, 24, 25, 26 ], 
          [ 3, 4, 5, 11, 12, 13, 14, 16, 18, 21, 25, 26, 27 ], 
          [ 3, 4, 6, 7, 10, 16, 17, 18, 20, 21, 23, 24, 27 ], 
          [ 3, 4, 6, 8, 9, 10, 11, 13, 15, 16, 19, 24, 25 ], 
          [ 3, 7, 9, 13, 14, 15, 16, 17, 19, 20, 22, 26, 27 ], 
          [ 4, 5, 6, 11, 12, 14, 15, 17, 19, 22, 23, 24, 27 ], 
          [ 4, 5, 7, 8, 9, 10, 12, 13, 14, 17, 20, 23, 25 ], 
          [ 9, 10, 11, 12, 13, 18, 19, 20, 21, 22, 23, 24, 26 ] ] ], 
  [ 4, 
      [ [ 1, 2, 3, 4, 5, 6, 9, 12, 16, 19, 20, 23, 26 ], 
          [ 1, 2, 3, 5, 7, 11, 14, 15, 18, 20, 23, 24, 25 ], 
          [ 1, 2, 3, 7, 9, 13, 14, 17, 19, 20, 21, 22, 27 ], 
          [ 1, 2, 4, 6, 7, 8, 10, 11, 13, 18, 20, 22, 26 ], 
          [ 1, 2, 4, 10, 12, 14, 15, 21, 22, 23, 25, 26, 27 ], 
          [ 1, 2, 5, 8, 12, 13, 17, 18, 19, 21, 24, 25, 26 ], 
          [ 1, 3, 4, 6, 8, 11, 13, 15, 17, 19, 23, 25, 27 ], 
          [ 1, 3, 5, 8, 10, 11, 12, 15, 16, 17, 20, 21, 22 ], 
          [ 1, 3, 6, 7, 8, 9, 10, 12, 18, 21, 23, 24, 27 ], 
          [ 1, 4, 5, 6, 7, 10, 13, 14, 15, 16, 19, 21, 24 ], 
          [ 1, 4, 8, 9, 14, 15, 16, 17, 18, 20, 24, 26, 27 ], 
          [ 1, 5, 6, 9, 11, 12, 13, 14, 16, 18, 22, 25, 27 ], 
          [ 1, 7, 9, 10, 11, 16, 17, 19, 22, 23, 24, 25, 26 ], 
          [ 2, 3, 4, 5, 10, 13, 16, 17, 18, 22, 23, 24, 27 ], 
          [ 2, 3, 4, 8, 9, 10, 11, 14, 16, 18, 19, 21, 25 ], 
          [ 2, 3, 6, 9, 10, 11, 12, 13, 14, 15, 17, 24, 26 ], 
          [ 2, 4, 5, 7, 8, 9, 11, 12, 15, 19, 22, 24, 27 ], 
          [ 2, 5, 6, 7, 8, 11, 14, 16, 17, 21, 23, 26, 27 ], 
          [ 2, 6, 7, 10, 12, 15, 16, 17, 18, 19, 20, 25, 27 ], 
          [ 2, 6, 8, 9, 13, 15, 16, 20, 21, 22, 23, 24, 25 ], 
          [ 3, 4, 5, 6, 7, 9, 15, 17, 18, 21, 22, 25, 26 ], 
          [ 3, 4, 7, 11, 12, 13, 16, 20, 21, 24, 25, 26, 27 ], 
          [ 3, 5, 6, 8, 10, 14, 19, 20, 22, 24, 25, 26, 27 ], 
          [ 3, 7, 8, 12, 13, 14, 15, 16, 18, 19, 22, 23, 26 ], 
          [ 4, 5, 7, 8, 9, 10, 12, 13, 14, 17, 20, 23, 25 ], 
          [ 4, 6, 11, 12, 14, 17, 18, 19, 20, 21, 22, 23, 24 ], 
          [ 5, 9, 10, 11, 13, 15, 18, 19, 20, 21, 23, 26, 27 ] ] ] ]
]]></Example>

We have constructed two <M>(27,13,6)</M> designs with blocks being
difference sets in <M>&ZZ;_9\rtimes &ZZ;_3</M>, which are not their
developments. Here are the slice invariants of the difference 
and non-difference group 3-cubes constructed so far.

<Example><![CDATA[gap> dc:=List(l3,x->DifferenceCube(SmallGroup(v,x[1]),x[2],3));;
gap> gc:=List(l5,x->GroupCube(SmallGroup(v,x[1]),x[2],3));;
gap> List(dc,SliceInvariant);
[ [ [ [ [ 1053, 27 ] ], 3 ] ], [ [ [ [ 1053, 27 ] ], 3 ] ] ]
gap> List(gc,SliceInvariant);
[ [ [ [ [ 27, 27 ] ], 2 ], [ [ [ 1053, 27 ] ], 1 ] ], 
  [ [ [ [ 27, 27 ] ], 2 ], [ [ [ 1053, 27 ] ], 1 ] ] ]
]]></Example>

More examples of difference and non-difference group cubes are available on 
our web page:
<P/>
<URL>https://web.math.pmf.unizg.hr/~krcko/results/cubes.html</URL> 

</Section>

<Section Label="Examples: Mosaics of Combinatorial Designs">
<Heading>Examples: Mosaics of Combinatorial Designs</Heading>

Mosaics of combinatorial designs were introduced in <Cite Key='GGP18'/> 
and a contruction from resolvable designs was proved. This construction 
of mosaics is implemented in &PAG; for affine designs.

<Example><![CDATA[gap> ag123:=AffineMosaic(1,2,3);
[ [ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3 ], 
  [ 2, 3, 1, 1, 2, 3, 2, 3, 1, 2, 3, 1 ], 
  [ 3, 1, 2, 1, 2, 3, 3, 1, 2, 3, 1, 2 ], 
  [ 1, 2, 3, 2, 3, 1, 3, 1, 2, 2, 3, 1 ], 
  [ 2, 3, 1, 2, 3, 1, 1, 2, 3, 3, 1, 2 ], 
  [ 3, 1, 2, 2, 3, 1, 2, 3, 1, 1, 2, 3 ], 
  [ 1, 2, 3, 3, 1, 2, 2, 3, 1, 3, 1, 2 ], 
  [ 2, 3, 1, 3, 1, 2, 3, 1, 2, 1, 2, 3 ], 
  [ 3, 1, 2, 3, 1, 2, 1, 2, 3, 2, 3, 1 ] ]
gap> MosaicParameters(ag123);
"2-(9,3,1) + 2-(9,3,1) + 2-(9,3,1)"
gap> ag232:=AffineMosaic(2,3,2);
[ [ 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2 ], 
  [ 2, 1, 1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 1 ], 
  [ 1, 2, 2, 1, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1 ], 
  [ 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 2, 1, 1, 2 ], 
  [ 1, 2, 1, 2, 1, 2, 2, 1, 2, 1, 2, 1, 2, 1 ], 
  [ 2, 1, 1, 2, 2, 1, 2, 1, 2, 1, 1, 2, 1, 2 ], 
  [ 1, 2, 2, 1, 2, 1, 2, 1, 1, 2, 2, 1, 1, 2 ], 
  [ 2, 1, 2, 1, 1, 2, 2, 1, 1, 2, 1, 2, 2, 1 ] ]
gap> MosaicParameters(ag232);
"3-(8,4,1) + 3-(8,4,1)"
]]></Example>

The command <C>AffineMosaic</C> uses the <Package>FinInG</Package> package 
and does not work if the package is not present. Tilings of groups with 
difference sets <Cite Key='CKZ15'/> give rise to mosaics of symmetric
designs. Here is an example of a <M>(31,6,1)</M> tiling and the corresponding
mosaic.

<Example><![CDATA[gap> t:=[ [ 1, 5, 11, 24, 25, 27 ], 
> [ 2, 10, 17, 19, 22, 23 ], 
> [ 3, 4, 7, 13, 15, 20 ], 
> [ 6, 8, 9, 14, 26, 30 ], 
> [ 12, 16, 18, 21, 28, 29 ] ];;
gap> m:=DifferenceMosaic(CyclicGroup(31), t);;
gap> MosaicParameters(m);
"2-(31,6,1) + 2-(31,6,1) + 2-(31,6,1) + 2-(31,6,1) + 2-(31,6,1)"
]]></Example>

The paper <Cite Key='VK24'/> gives some interesting small examples of mosaics. 
Files containing these examples are available on the web page 

<P/>

<URL>https://web.math.pmf.unizg.hr/~krcko/results/mosaics.html</URL> 

<Example><![CDATA[gap> m:=ReadMat("13-346ex.txt")[1];
[ [ 1, 3, 3, 3, 2, 3, 2, 2, 3, 1, 3, 2, 1, 1, 3, 2, 2, 3, 3, 1, 3, 3, 3, 2, 1, 2 ], 
  [ 1, 1, 3, 3, 3, 2, 3, 2, 2, 3, 1, 3, 2, 2, 1, 3, 2, 2, 3, 3, 1, 3, 3, 3, 2, 1 ], 
  [ 2, 1, 1, 3, 3, 3, 2, 3, 2, 2, 3, 1, 3, 1, 2, 1, 3, 2, 2, 3, 3, 1, 3, 3, 3, 2 ], 
  [ 3, 2, 1, 1, 3, 3, 3, 2, 3, 2, 2, 3, 1, 2, 1, 2, 1, 3, 2, 2, 3, 3, 1, 3, 3, 3 ], 
  [ 1, 3, 2, 1, 1, 3, 3, 3, 2, 3, 2, 2, 3, 3, 2, 1, 2, 1, 3, 2, 2, 3, 3, 1, 3, 3 ], 
  [ 3, 1, 3, 2, 1, 1, 3, 3, 3, 2, 3, 2, 2, 3, 3, 2, 1, 2, 1, 3, 2, 2, 3, 3, 1, 3 ], 
  [ 2, 3, 1, 3, 2, 1, 1, 3, 3, 3, 2, 3, 2, 3, 3, 3, 2, 1, 2, 1, 3, 2, 2, 3, 3, 1 ], 
  [ 2, 2, 3, 1, 3, 2, 1, 1, 3, 3, 3, 2, 3, 1, 3, 3, 3, 2, 1, 2, 1, 3, 2, 2, 3, 3 ], 
  [ 3, 2, 2, 3, 1, 3, 2, 1, 1, 3, 3, 3, 2, 3, 1, 3, 3, 3, 2, 1, 2, 1, 3, 2, 2, 3 ], 
  [ 2, 3, 2, 2, 3, 1, 3, 2, 1, 1, 3, 3, 3, 3, 3, 1, 3, 3, 3, 2, 1, 2, 1, 3, 2, 2 ], 
  [ 3, 2, 3, 2, 2, 3, 1, 3, 2, 1, 1, 3, 3, 2, 3, 3, 1, 3, 3, 3, 2, 1, 2, 1, 3, 2 ], 
  [ 3, 3, 2, 3, 2, 2, 3, 1, 3, 2, 1, 1, 3, 2, 2, 3, 3, 1, 3, 3, 3, 2, 1, 2, 1, 3 ], 
  [ 3, 3, 3, 2, 3, 2, 2, 3, 1, 3, 2, 1, 1, 3, 2, 2, 3, 3, 1, 3, 3, 3, 2, 1, 2, 1 ] ]
gap> MosaicParameters(m);
"2-(13,3,1) + 2-(13,4,2) + 2-(13,6,5)"
]]></Example>

This is the first example of an inhomogenous mosaic, containing designs
with distinct parameters.

<Example><![CDATA[gap> m1:=ReadMat("9-3-2ex1.txt")[1];
[ [ 1, 2, 1, 1, 2, 1, 1, 3, 3, 1, 2, 3, 1, 3, 2, 1, 3, 3, 2, 2, 3, 2, 3, 2 ], 
  [ 1, 1, 2, 1, 1, 2, 3, 1, 3, 3, 1, 2, 2, 1, 3, 3, 1, 3, 3, 2, 2, 2, 2, 3 ], 
  [ 2, 1, 1, 2, 1, 1, 3, 3, 1, 2, 3, 1, 3, 2, 1, 3, 3, 1, 2, 3, 2, 3, 2, 2 ], 
  [ 1, 3, 2, 2, 3, 3, 1, 2, 1, 3, 3, 1, 2, 1, 2, 2, 2, 3, 1, 3, 1, 1, 3, 2 ], 
  [ 2, 1, 3, 3, 2, 3, 1, 1, 2, 1, 3, 3, 2, 2, 1, 3, 2, 2, 1, 1, 3, 2, 1, 3 ], 
  [ 3, 2, 1, 3, 3, 2, 2, 1, 1, 3, 1, 3, 1, 2, 2, 2, 3, 2, 3, 1, 1, 3, 2, 1 ], 
  [ 2, 3, 3, 1, 3, 2, 3, 2, 2, 2, 2, 1, 1, 3, 3, 2, 1, 1, 1, 2, 3, 3, 1, 1 ], 
  [ 3, 2, 3, 2, 1, 3, 2, 3, 2, 1, 2, 2, 3, 1, 3, 1, 2, 1, 3, 1, 2, 1, 3, 1 ], 
  [ 3, 3, 2, 3, 2, 1, 2, 2, 3, 2, 1, 2, 3, 3, 1, 1, 1, 2, 2, 3, 1, 1, 1, 3 ] ]
gap> MosaicParameters(m1);
"2-(9,3,2) + 2-(9,3,2) + 2-(9,3,2)"
gap> m2:=ReadMat("9-3-2ex2.txt")[1];
[ [ 1, 2, 1, 1, 2, 1, 1, 3, 3, 1, 3, 3, 1, 3, 2, 1, 2, 3, 3, 2, 2, 3, 2, 2 ], 
  [ 1, 1, 2, 1, 1, 2, 3, 1, 3, 3, 1, 3, 2, 1, 3, 3, 1, 2, 2, 3, 2, 2, 3, 2 ], 
  [ 2, 1, 1, 2, 1, 1, 3, 3, 1, 3, 3, 1, 3, 2, 1, 2, 3, 1, 2, 2, 3, 2, 2, 3 ], 
  [ 1, 3, 2, 3, 3, 1, 2, 2, 1, 2, 1, 3, 3, 3, 2, 2, 3, 2, 1, 2, 1, 1, 3, 1 ], 
  [ 2, 1, 3, 1, 3, 3, 1, 2, 2, 3, 2, 1, 2, 3, 3, 2, 2, 3, 1, 1, 2, 1, 1, 3 ], 
  [ 3, 2, 1, 3, 1, 3, 2, 1, 2, 1, 3, 2, 3, 2, 3, 3, 2, 2, 2, 1, 1, 3, 1, 1 ], 
  [ 2, 3, 3, 2, 3, 2, 2, 3, 1, 1, 2, 2, 1, 1, 2, 3, 1, 1, 1, 3, 3, 3, 1, 2 ], 
  [ 3, 2, 3, 2, 2, 3, 1, 2, 3, 2, 1, 2, 2, 1, 1, 1, 3, 1, 3, 1, 3, 2, 3, 1 ], 
  [ 3, 3, 2, 3, 2, 2, 3, 1, 2, 2, 2, 1, 1, 2, 1, 1, 1, 3, 3, 3, 1, 1, 2, 3 ] ]
gap> MosaicParameters(m2);
"2-(9,3,2) + 2-(9,3,2) + 2-(9,3,2)"
]]></Example>

These two mosaics cannot be obtained by the construction from <Cite Key='GGP18'/>.  
The first mosaic contains three isomorphic copies of a <M>2</M>-<M>(9,3,2)</M> design 
that is not resolvable.

<Example><![CDATA[gap> d1:=BlockDesignFilter(MosaicToBlockDesigns(m1));
[ rec( blocks := [ [ 1, 2, 4 ], [ 1, 2, 7 ], [ 1, 3, 6 ], [ 1, 3, 9 ], 
          [ 1, 4, 5 ], [ 1, 5, 8 ], [ 1, 6, 7 ], [ 1, 8, 9 ], [ 2, 3, 5 ], 
          [ 2, 3, 8 ], [ 2, 4, 8 ], [ 2, 5, 6 ], [ 2, 6, 9 ], [ 2, 7, 9 ], 
          [ 3, 4, 6 ], [ 3, 4, 7 ], [ 3, 5, 9 ], [ 3, 7, 8 ], [ 4, 5, 7 ], 
          [ 4, 6, 9 ], [ 4, 8, 9 ], [ 5, 6, 8 ], [ 5, 7, 9 ], [ 6, 7, 8 ] ], 
      isBlockDesign := true, v := 9 ) ]
gap> MakeResolutionsComponent(d1[1]);
gap> d1[1].resolutions.list;
[  ]
]]></Example>

The second mosaic contains three non-isomorphic designs, one resolvable and two
not resolvable.

<Example><![CDATA[gap> d2:=BlockDesignFilter(MosaicToBlockDesigns(m2));
[ rec( blocks := [ [ 1, 2, 4 ], [ 1, 2, 5 ], [ 1, 3, 4 ], [ 1, 3, 6 ], 
          [ 1, 5, 8 ], [ 1, 6, 7 ], [ 1, 7, 9 ], [ 1, 8, 9 ], [ 2, 3, 5 ], 
          [ 2, 3, 6 ], [ 2, 4, 8 ], [ 2, 6, 9 ], [ 2, 7, 8 ], [ 2, 7, 9 ], 
          [ 3, 4, 7 ], [ 3, 5, 9 ], [ 3, 7, 8 ], [ 3, 8, 9 ], [ 4, 5, 7 ], 
          [ 4, 5, 9 ], [ 4, 6, 8 ], [ 4, 6, 9 ], [ 5, 6, 7 ], [ 5, 6, 8 ] ], 
      isBlockDesign := true, v := 9 ), 
  rec( blocks := [ [ 1, 2, 5 ], [ 1, 2, 7 ], [ 1, 3, 4 ], [ 1, 3, 9 ], 
          [ 1, 4, 7 ], [ 1, 5, 6 ], [ 1, 6, 8 ], [ 1, 8, 9 ], [ 2, 3, 6 ], 
          [ 2, 3, 8 ], [ 2, 4, 6 ], [ 2, 4, 9 ], [ 2, 5, 8 ], [ 2, 7, 9 ], 
          [ 3, 4, 5 ], [ 3, 5, 7 ], [ 3, 6, 9 ], [ 3, 7, 8 ], [ 4, 5, 8 ], 
          [ 4, 6, 7 ], [ 4, 8, 9 ], [ 5, 6, 9 ], [ 5, 7, 9 ], [ 6, 7, 8 ] ], 
      isBlockDesign := true, v := 9 ), 
  rec( blocks := [ [ 1, 2, 4 ], [ 1, 2, 8 ], [ 1, 3, 6 ], [ 1, 3, 7 ], 
          [ 1, 4, 5 ], [ 1, 5, 9 ], [ 1, 6, 7 ], [ 1, 8, 9 ], [ 2, 3, 5 ], 
          [ 2, 3, 9 ], [ 2, 4, 8 ], [ 2, 5, 6 ], [ 2, 6, 7 ], [ 2, 7, 9 ], 
          [ 3, 4, 6 ], [ 3, 4, 8 ], [ 3, 5, 9 ], [ 3, 7, 8 ], [ 4, 5, 7 ], 
          [ 4, 6, 9 ], [ 4, 7, 9 ], [ 5, 6, 8 ], [ 5, 7, 8 ], [ 6, 8, 9 ] ], 
      isBlockDesign := true, v := 9 ) ]
gap> MakeResolutionsComponent(d2[1]);
gap> MakeResolutionsComponent(d2[2]);
gap> MakeResolutionsComponent(d2[3]);
gap> d2[1].resolutions.list;
[ rec( autGroup := Group([ (1,5,8)(2,6,9)(3,4,7), (1,7,6)(2,8,4)(3,9,5), (1,2)
          (4,5)(7,9) ]), 
      partition := 
        [ 
          rec( blocks := [ [ 1, 2, 4 ], [ 3, 8, 9 ], [ 5, 6, 7 ] ], 
              isBlockDesign := true, v := 9 ), 
          rec( blocks := [ [ 1, 2, 5 ], [ 3, 7, 8 ], [ 4, 6, 9 ] ], 
              isBlockDesign := true, v := 9 ), 
          rec( blocks := [ [ 1, 3, 4 ], [ 2, 7, 9 ], [ 5, 6, 8 ] ], 
              isBlockDesign := true, v := 9 ), 
          rec( blocks := [ [ 1, 3, 6 ], [ 2, 7, 8 ], [ 4, 5, 9 ] ], 
              isBlockDesign := true, v := 9 ), 
          rec( blocks := [ [ 1, 5, 8 ], [ 2, 6, 9 ], [ 3, 4, 7 ] ], 
              isBlockDesign := true, v := 9 ), 
          rec( blocks := [ [ 1, 6, 7 ], [ 2, 4, 8 ], [ 3, 5, 9 ] ], 
              isBlockDesign := true, v := 9 ), 
          rec( blocks := [ [ 1, 7, 9 ], [ 2, 3, 5 ], [ 4, 6, 8 ] ], 
              isBlockDesign := true, v := 9 ), 
          rec( blocks := [ [ 1, 8, 9 ], [ 2, 3, 6 ], [ 4, 5, 7 ] ], 
              isBlockDesign := true, v := 9 ) ] ) ]
gap> d2[2].resolutions.list;
[  ]
gap> d2[3].resolutions.list;
[  ]
]]></Example>

Finally, here is a mosaic of projective planes of order <M>3</M> from <Cite Key='VK24'/>. 

<Example><![CDATA[gap> m:=ReadMat("13-4-1.txt")[1];
[ [ 0, 1, 2, 1, 3, 2, 3, 1, 1, 3, 3, 2, 2 ], 
  [ 3, 0, 2, 3, 2, 1, 2, 1, 2, 3, 1, 1, 3 ], 
  [ 3, 1, 0, 2, 1, 3, 3, 3, 2, 2, 1, 2, 1 ], 
  [ 3, 3, 1, 0, 1, 1, 2, 2, 1, 2, 3, 3, 2 ], 
  [ 2, 1, 1, 2, 0, 2, 2, 3, 3, 1, 3, 1, 3 ], 
  [ 2, 3, 2, 3, 3, 0, 1, 3, 1, 2, 2, 1, 1 ], 
  [ 1, 2, 2, 2, 3, 3, 0, 2, 1, 1, 1, 3, 3 ], 
  [ 3, 2, 3, 1, 3, 1, 2, 0, 3, 1, 2, 2, 1 ], 
  [ 1, 1, 3, 2, 2, 1, 1, 3, 0, 3, 2, 3, 2 ], 
  [ 1, 3, 3, 1, 1, 2, 3, 2, 2, 0, 2, 1, 3 ], 
  [ 1, 2, 1, 3, 2, 2, 3, 1, 3, 2, 0, 3, 1 ], 
  [ 2, 2, 3, 3, 1, 3, 1, 1, 2, 1, 3, 0, 2 ], 
  [ 2, 3, 1, 1, 2, 3, 1, 2, 3, 3, 1, 2, 0 ] ]
gap> MosaicParameters(m);
"2-(13,4,1) + 2-(13,4,1) + 2-(13,4,1)"
gap> aut:=MatAut(m);
Group([ (1,3,2)(4,6,5)(7,9,8)(10,12,11)(14,16,15)(17,19,18)(20,22,21)
  (23,25,24)(28,30,29) ])
gap> Size(aut);
3
]]></Example>

The full automorphism group of this mosaic is of order <M>3</M>, so it cannot
be obtained by tiling groups with <M>(13,4,1)</M> difference sets.

</Section>
</Chapter>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<Chapter Label="The PAG Functions">
<Heading>The PAG Functions</Heading>

The following functions are available in the PAG package.

<Section Label="Working With Permutation Groups">
<Heading>Working With Permutation Groups</Heading>

<#Include Label="CyclicPerm">

<#Include Label="ToGroup">

<#Include Label="MovePerm">

<#Include Label="MoveGroup">

<#Include Label="MultiPerm">

<#Include Label="MultiGroup">

<#Include Label="RestrictedGroup">

<#Include Label="PrimitiveGroupsOfDegree">

<#Include Label="TransitiveGroupsOfDegree">

<#Include Label="AllSubgroupsConjugation">

<#Include Label="PermRepresentationRight">

<#Include Label="PermRepresentationLeft">

<#Include Label="ExtendedPermRepresentation">

</Section>

<Section Label="Generating Ortbits">
<Heading>Generating Orbits</Heading>

<#Include Label="SubsetOrbitRep">

<#Include Label="SubsetOrbitRepShort1">

<#Include Label="SubsetOrbitRepIN">

<#Include Label="IsGoodSubsetOrbit">

<#Include Label="SmallLambdaFilter">

<#Include Label="OrbitFilter1">

<#Include Label="OrbitFilter2">

</Section>

<Section Label="Constructing Objects">
<Heading>Constructing Objects</Heading>

<#Include Label="KramerMesnerSearch">

<#Include Label="KramerMesnerMat">

<#Include Label="CompatibilityMat">

<#Include Label="SolveKramerMesner">

<#Include Label="BaseBlocks">

<#Include Label="ExpandMatRHS">

<#Include Label="RightDevelopment">

<#Include Label="LeftDevelopment">

</Section>

<Section Label="Inspecting Objects and Other Functions">
<Heading>Inspecting Objects and Other Functions</Heading>

<#Include Label="BlockDesignAut">

<#Include Label="BlockDesignFilter">

<#Include Label="IntersectionNumbers">

<#Include Label="BlockScheme">

<#Include Label="PointPairScheme">

<#Include Label="TDesignB">

<#Include Label="IversonBracket">

<#Include Label="SymmetricDifference">

<#Include Label="AddWeights">

</Section>

<Section Label="Latin Squares">
<Heading>Latin Squares</Heading>

<#Include Label="ReadMOLS">

<#Include Label="WriteMOLS">

<#Include Label="CayleyTableOfGroup">

<#Include Label="FieldToMOLS">

<#Include Label="MOLSToOrthogonalArray">

<#Include Label="OrthogonalArrayToMOLS">

<#Include Label="MOLSToTransversalDesign">

<#Include Label="TransversalDesignToMOLS">

<#Include Label="MOLSAut">

<#Include Label="MOLSFilter">

<#Include Label="IsAutotopyGroup">

<#Include Label="MOLSSubsetOrbitRep">

<#Include Label="KramerMesnerMOLS">

<#Include Label="KramerMesnerMOLSAutotopy">

<#Include Label="KramerMesnerMOLSAutoparatopy">

</Section>

<Section Label="Cubes of Symmetric Designs">
<Heading>Cubes of Symmetric Designs</Heading>

<#Include Label="DifferenceCube">

<#Include Label="GroupCube">

<#Include Label="CubeSlice">

<#Include Label="CubeSlices">

<#Include Label="CubeLayer">

<#Include Label="CubeLayers">

<#Include Label="CubeToOrthogonalArray">

<#Include Label="OrthogonalArrayToCube">

<#Include Label="CubeToTransversalDesign">

<#Include Label="TransversalDesignToCube">

<#Include Label="LatinSquareToCube">

<#Include Label="CubeTest">

<#Include Label="SliceInvariant">

<#Include Label="CubeAut">

<#Include Label="CubeFilter">

<#Include Label="SDPSeriesGroup">

<#Include Label="SDPSeriesDesign">

</Section>

<Section Label="Hadamard Matrices">
<Heading>Hadamard Matrices</Heading>

<#Include Label="IsHadamardMat">

<#Include Label="IsProperHadamardMat">

<#Include Label="Paley1Mat">

<#Include Label="Paley2Mat">

<#Include Label="Paley3DMat">

<#Include Label="SDPSeriesHadamardMat">

<#Include Label="AllOnesMat">

<#Include Label="ProductConstructionMat">

<#Include Label="DigitConstructionMat">

<#Include Label="CyclicDimensionIncrease">

<#Include Label="HadamardMatAut">

<#Include Label="HadamardMatFilter">

<#Include Label="HadamardToIncidence">

<#Include Label="IncidenceToHadamard">

</Section>

<Section Label="Mosaics of Combinatorial Designs">
<Heading>Mosaics of Combinatorial Designs</Heading>

<#Include Label="MosaicParameters">

<#Include Label="BlocksToIncidenceMat">

<#Include Label="IncidenceMatToBlocks">

<#Include Label="MosaicToBlockDesigns">

<#Include Label="ReadMat">

<#Include Label="WriteMat">

<#Include Label="AffineMosaic">

<#Include Label="DifferenceMosaic">

<#Include Label="PowersMosaic">

<#Include Label="MatAut">

<#Include Label="MatFilter">

</Section>

<Section Label="Global Options">
<Heading>Global Options</Heading>

<#Include Label="PAGGlobalOptions">

</Section>

</Chapter>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

